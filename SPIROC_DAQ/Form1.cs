// this file define eventhandle function of Main_Form, most of function is auto-generated by Visual Stuido Designer
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using CyUSB;
using NationalInstruments.VisaNS;

namespace SPIROC_DAQ
{
    public partial class Main_Form : Form
    {

        private USBDeviceList usbDevices;
        private CyUSBDevice myDevice;
        private CyBulkEndPoint bulkInEndPt;
        private CyBulkEndPoint bulkOutEndPt;

        //private MessageBasedSession AFG_Session; //for test, should never use
        private AFG3252 SignalSource = new AFG3252();

        
        private bool usbStatus = false;
        private string fileDic;    // store path of data file
        private string fileName;
        private const int VID = 0x04B4;
        private const int PID = 0x1004;
        private CancellationTokenSource dataAcqTks = new CancellationTokenSource();
        private CancellationTokenSource voltageSweepTks = new CancellationTokenSource();
        private CancellationTokenSource scSweepTks = new CancellationTokenSource();
        private CancellationTokenSource specialTaskTks = new CancellationTokenSource();
        private CancellationTokenSource hv_setTks = new CancellationTokenSource();
        private StringBuilder exceptionReport = new StringBuilder();

        private string rx_Command = @"\b[0-9a-fA-F]{4}\b";//match 16 bit Hex
        private string rx_Byte = @"\b[0-9a-fA-F]{2}\b";//match 8 bit Hex
        private string rx_Bit = @"\b[0-1]{1,12}\b"; //match 12bit Binary
        private string rx_Integer = @"^\d+$";   //匹配非负 整数

        private int settingChoosen = 0;
        private decimal current_hv = 50;
        Iversion slowConfig;
        SC_board_manager slowControlManager = new SC_board_manager();
        
        List<SC_model> slowConfig_2B_store = new List<SC_model>();
        List<SC_model_2E> slowConfig_2E_store = new List<SC_model_2E>();
        SC_model slowConfig_2B_1 = new SC_model();
        SC_model slowConfig_2B_2 = new SC_model();
        SC_model slowConfig_2B_3 = new SC_model();
        SC_model slowConfig_2B_4 = new SC_model();
        SC_model_2E slowConfig_2E_1 = new SC_model_2E();
        SC_model_2E slowConfig_2E_2 = new SC_model_2E();
        SC_model_2E slowConfig_2E_3 = new SC_model_2E();
        SC_model_2E slowConfig_2E_4 = new SC_model_2E();
        Probe_2E Probe_config = new Probe_2E();
        private DateTime startTime;
        // recording information such as slow control config of every data;
        private string recordPath = "record.txt";
        private FileStream resultRecord;

        private int pwr_vector = 0x0f;
        // for changing textbox1.Text from different thread (not from main thread)
        delegate void SetTextCallback(string text);
        public int version_num=2;
        public Main_Form()
        {
            InitializeComponent();
            CheckForIllegalCrossThreadCalls = false;
            bindEventHandle(inputDAC_group, new EventHandler(inputDAC_Changed));
            bindEventHandle(discri_groupbox, new EventHandler(discri_Changed));
            bindEventHandle(preamp_group, new EventHandler(preamp_Changed));
            File_path_showbox.Text = folderBrowserDialog1.SelectedPath;
            fileDic = folderBrowserDialog1.SelectedPath + "\\\\default_test";
            slowControlManager.clearChip();
            // Dynamic list of USB devices bound to CyUSB.sys
            usbDevices = new USBDeviceList(CyConst.DEVICES_CYUSB);
            loadsettings();
            slowConfig_2B_store.Add(slowConfig_2B_1);
            slowConfig_2B_store.Add(slowConfig_2B_2);
            slowConfig_2B_store.Add(slowConfig_2B_3);
            slowConfig_2B_store.Add(slowConfig_2B_4);
            slowConfig_2E_store.Add(slowConfig_2E_1);
            slowConfig_2E_store.Add(slowConfig_2E_2);
            slowConfig_2E_store.Add(slowConfig_2E_3);
            slowConfig_2E_store.Add(slowConfig_2E_4);
            if (version_num == 1)
            {
                slowConfig = slowConfig_2B_store[0];


                slowConfig.save_settings(0);
                refreshParamPanel_2B();
            }
            if (version_num == 2)
            {
                slowConfig = slowConfig_2E_1;
                slowConfig.save_settings(0);               
                refreshParamPanel_2E();
            }
           
            //slowConfig.recall_settings(0);
            // Adding event handles for action of attachment and removal of device
            usbDevices.DeviceAttached += new EventHandler(deviceAttached);
            usbDevices.DeviceRemoved += new EventHandler(deviceRemoved);
            Probe_config.init();
            check_USB();
        }

        // Event handler
        private void deviceAttached(object sender, EventArgs e)
        {
            check_USB();
            return;
        }

        private void deviceRemoved(object sender, EventArgs e)
        {
            check_USB();
        }

        private void close_windows(object sender, FormClosingEventArgs e)
        {
            if(SignalSource.isConnected())
                SignalSource.Close();
            if (resultRecord != null)
            {
                resultRecord.Close();
                resultRecord.Dispose();
            }
        }

        private void normal_usbcon_button_Click(object sender, EventArgs e)
        {
            if (check_USB() != true)
            {
                MessageBox.Show("USB can't be connected", "Error");
            }

        }

        private void normal_config_button_Click(object sender, EventArgs e)
        {
            int byte_count = 0;

            byte[] cmdBytes = new byte[2];
            byte[] bit_block = new byte[1000];  //SPIROC2b has 929 config bit, 929 / 8 = 116 ... 1, need 117 bytes, SPIROC2E need 1186 / 8 = 148 ... 2, so 149 bytes


            // Is not pretty use slowControlManager this way!!!!!!! but I just used it.
            // setting should detech with config
            if(chip_selection_combo.Text == "Global")
            {
                for(int i = 0; i< chip_num_input.Value; i++)
                {
                    if(version_num == 1)
                    {
                        slowConfig_2B_store[i] = Copy<SC_model>(slowConfig_2B_1);
                        slowConfig_2B_store[i].set_property(slowConfig_2B_1.settings["CHIPID"], reverse_bit(bin2gray((uint)(chip_num_input.Value - i)), 8));  // the last chip config first
                    }
                    else if(version_num == 2)
                    {
                        slowConfig_2E_store[i] = Copy<SC_model_2E>(slowConfig_2E_1);
                        slowConfig_2E_store[i].set_property(slowConfig_2E_1.settings["CHIPID"], reverse_bit(bin2gray((uint)(chip_num_input.Value - i)), 8));  // the last chip config first
                    }                 
                }
                slowControlManager.clearChip();
                for (int i = 0; i < chip_num_input.Value; i++)
                {
                    if(version_num == 1)
                    {
                        slowControlManager.pushChip(slowConfig_2B_store[i]);
                    }
                    else if(version_num == 2)
                    {
                        slowControlManager.pushChip(slowConfig_2E_store[i]);
                    }
                    
                }

            }          
            byte_count = slowControlManager.bit_transform(bit_block);

            // reset spiroc2b           
            //CommandSend(0x0400, 2);
            Thread.Sleep(100);

            // set probe/sc setting as slow control
            cmdBytes[1] = 0x06;
            cmdBytes[0] = 0x01;
            CommandSend(cmdBytes, 2);

            // choose data transfer to sc buffer
            cmdBytes[1] = 0x05;
            cmdBytes[0] = 0x01;
            CommandSend(cmdBytes, 2);
            Thread.Sleep(100);
            // send config data
            cmdBytes[1] = 0x03;
            for (int i = 0; i < byte_count; i++)
            {
                cmdBytes[0] = bit_block[i];
                CommandSend(cmdBytes, 2);
                //Thread.Sleep(100);
            }

            // close channel of data to sc buffer
            cmdBytes[1] = 0x05;
            cmdBytes[0] = 0x00;

            CommandSend(cmdBytes, 2);

            // start slow config from fpga to asic
            cmdBytes[1] = 0x08;
            cmdBytes[0] = 0x00;
            CommandSend(cmdBytes, 2);

            // show relative message
            textBox1.AppendText("Slow control config successed\n");
            normal_acq_button.Enabled = true;
            Config_status_label.Text = "Configured";
            Config_status_label.ForeColor = Color.Green;
            
        }

        private void normal_acq_button_Click(object sender, EventArgs e)
        {
            byte[] cmdBytes = new byte[2];
            // clear USB fifo

            // start acq cmd is 0x0100;
            cmdBytes[1] = 0x01;
            cmdBytes[0] = 0x00;

            dataAcqTks.Dispose();       //clean up old token source
            dataAcqTks = new CancellationTokenSource(); // generate a new token

            CommandSend(cmdBytes, 2);
            // check USB status
            if (usbStatus == false)
            {
                MessageBox.Show("USB is not connected");
            }

            // create file writer
            fileName = string.Format("{0:yyyyMMdd_HHHHmmss}", DateTime.Now) + ".dat";
            if (!Directory.Exists(fileDic))
            {
                Directory.CreateDirectory(fileDic);
            }

            BinaryWriter bw = new BinaryWriter(File.Open(fileDic + "\\\\" + fileName, FileMode.Append,FileAccess.Write,FileShare.Read));
            resultRecord = new FileStream(fileDic + '\\' + recordPath, FileMode.Append);

            // Start data acquision thread
            try
            {
                Task dataAcqTsk = Task.Factory.StartNew(() => this.dataAcq_threadFunc(dataAcqTks.Token, bw), dataAcqTks.Token);
                startTime = DateTime.Now;
                timer1.Start();
            }
            catch (AggregateException excption)
            {

                foreach (var v in excption.InnerExceptions)
                {

                    exceptionReport.AppendLine(excption.Message + " " + v.Message);
                }

            }
            normal_stop_button.Enabled = true;
            normal_acq_button.Enabled = false;

            Acq_status_label.ForeColor = Color.Firebrick;
            Acq_status_label.Text = "Acquiring";

            // record information of this acq action
            byte[] titleByte = Encoding.Default.GetBytes(fileName+'\n');
            byte[] infByte = Encoding.Default.GetBytes(slowConfig.getTag()+'\n'+'\n');
            resultRecord.Write(titleByte, 0, titleByte.Length);
            resultRecord.Write(infByte, 0, infByte.Length);
            
        }

        private void normal_stop_button_Click(object sender, EventArgs e)
        {
            byte[] cmdBytes = new byte[2];

            // start acq cmd is 0x0200;
            cmdBytes[1] = 0x02;
            cmdBytes[0] = 0x00;

            CommandSend(cmdBytes, 2);

            // check USB status
            if (usbStatus == false)
            {
                MessageBox.Show("USB is not connected");
            }
            dataAcqTks.Cancel();

            timer1.Stop();
            time_textbox.Text = "00:00:00:00";

            resultRecord.Close();

            normal_acq_button.Enabled = true;
            normal_stop_button.Enabled = false;

            Acq_status_label.ForeColor = Color.Black;
            Acq_status_label.Text = "IDLE";

        }

        private void File_path_select_button_Click(object sender, EventArgs e)
        {
            folderBrowserDialog1.ShowDialog();
            fileDic = folderBrowserDialog1.SelectedPath;
            File_path_showbox.Text = fileDic;

        }



        private void trig_dac_value_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(trig_dac_value.Text))
            {
                value = uint.Parse(trig_dac_value.Text);
                if (0 <= value && value <= 1023)
                {
                    slowConfig.set_property(slowConfig.settings["TRIG_DAC"], value);
                    return;
                }
            }

            MessageBox.Show("value need be in range of 0-1023", "Value invalid");

        }

        private void gain_sel_value_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(gain_sel_value.Text))
            {
                value = uint.Parse(gain_sel_value.Text);
                if (0 <= value && value <= 1023)
                {
                    slowConfig.set_property(slowConfig.settings["GAIN_DAC"], value);
                    return;
                }
            }

            MessageBox.Show("value need be in range of 0-1023", "Value invalid");

        }


        private void inputDAC_Changed(object sender, EventArgs e)
        {
            int chnNum;
            string controlName = (sender as Control).Name;
            Regex chnNum_reg = new Regex(@"inputdac(\d+)_(value|enable)");

            var result = chnNum_reg.Match(controlName);
            chnNum = int.Parse(result.Groups[1].Value);
            if (string.Equals(result.Groups[2].Value, "value"))
            {
                //is textbox whose name is inputdacx_value
                uint value;
                Regex rx_int = new Regex(rx_Integer);
                if(rx_int.IsMatch((sender as TextBox).Text))
                {
                    value = uint.Parse((sender as TextBox).Text);
                    string Key = "INDAC" + chnNum.ToString();
                    uint old_value = slowConfig.get_property(slowConfig.settings[Key.ToString ()]);
                    uint new_value = (value << 1) + (old_value & 1);
                    slowConfig.set_property(slowConfig.settings[Key.ToString()], new_value);
                }
                else
                {
                    MessageBox.Show("Input DAC is configured by 8bit, 0-255 is valid", "Invalid Value");
                }
            }
            else
            {
                //is checkbox whose name is inputdacx_enable;
                bool isEnable = (sender as CheckBox).Checked;
                uint value = isEnable ? 1U : 0U;
                string Key = "INDAC" + chnNum.ToString();
                uint old_value = slowConfig.get_property(slowConfig.settings[Key.ToString()]);
                uint new_value = (old_value & 0x1fe) + value;
                slowConfig.set_property(slowConfig.settings[Key.ToString()], new_value);
                (sender as CheckBox).Text = isEnable ? "Enable" : "Disable";
            }


        }


        private void preamp_Changed(object sender, EventArgs e)
        {
            int chnNum;
            string controlName = (sender as Control).Name;
            Regex chnNum_reg = new Regex(@"preamp(Check|Value)_(\d+)");     // Attention! Controler name must be named strictly in this way

            var result = chnNum_reg.Match(controlName);     //Now we get channel number in result
            chnNum = int.Parse(result.Groups[2].Value);     // chnNum is a int
            Queue<int> changedChn = new Queue<int>();
            if(preamp_global_sw.Checked is true)
            {
                for(chnNum = 0; chnNum < 36; chnNum++)
                {
                    changedChn.Enqueue(chnNum);
                }
            }
            else
            {
                changedChn.Enqueue(chnNum);
            }
            string Key;
            uint old_value = 0;
            uint new_value = 0;
            if (string.Equals(result.Groups[1].Value, "Value"))
            {
                //is textbox whose name is preampValue_x
                uint value;
                Regex rx_int = new Regex(rx_Integer);   //rx_Integer is defined outside in Form. @"^\d+$"

                //make sure the input text is a integer
                if (rx_int.IsMatch((sender as TextBox).Text))
                {
                    value = uint.Parse((sender as TextBox).Text);

                    if (version_num == 2)// 2E version
                    {
                        if (HLGain_Select.Text == "High Gain")
                        {
                            foreach(int chn in changedChn)
                            {
                                Key = "PREAMP_GAIN" + chn.ToString();
                                old_value = slowConfig.get_property(slowConfig.settings[Key.ToString()]);
                                new_value = (reverse_bit(value, 6) << 9) + (old_value & 0x1ff); //0x1ff is 000000 111111 111
                                slowConfig.set_property(slowConfig.settings[Key.ToString()], new_value);
                            }
                        }
                        else if(HLGain_Select.Text == "Low Gain")
                        {
                            foreach(int chn in changedChn)
                            {
                                Key = "PREAMP_GAIN" + chn.ToString();
                                old_value = slowConfig.get_property(slowConfig.settings[Key.ToString()]);
                                new_value = (reverse_bit(value, 6) << 3) + (old_value & 0x3E07);  // 0x3E07 is 111111 000000 111
                                slowConfig.set_property(slowConfig.settings[Key.ToString()], new_value);
                            }
                        }
                        refreshParamPanel_2E();
                    } 
                    else if(version_num == 1)// 2B version
                    {
                        foreach(int chn in changedChn)
                        {
                            Key = "PREAMP_GAIN" + chn.ToString();
                            old_value = slowConfig.get_property(slowConfig.settings[Key.ToString()]);
                            new_value = (reverse_bit(value, 6) << 2) + (old_value & 0x3); //0x3 is 00000 11
                            slowConfig.set_property(slowConfig.settings[Key.ToString()], new_value);
                        }
                        refreshParamPanel_2B();
                    }                                   
                }
                else
                {
                    MessageBox.Show("Input DAC is configured by 6bit,LSB -> MSB, 0-63 is valid", "Invalid Value");
                }
            }
            else if(string.Equals(result.Groups[1].Value, "Check"))
            {
                //is checkbox whose name is preampCheck_x;
                bool isEnable = (sender as CheckBox).Checked;
                uint value = isEnable ? 0U : 1U;
                if (version_num == 2)// 2E version
                {
                    foreach (int chn in changedChn)
                    {
                        Key = "PREAMP_GAIN" + chn.ToString();
                        old_value = slowConfig.get_property(slowConfig.settings[Key.ToString()]);
                        new_value = (old_value & 0x4FFE) + (value & 0x1); //0x4FFE is 111111 111111 110
                        slowConfig.set_property(slowConfig.settings[Key.ToString()], new_value);
                    }
                    refreshParamPanel_2E();
                }
                else if (version_num == 1)// 2B version
                {
                    foreach (int chn in changedChn)
                    {
                        Key = "PREAMP_GAIN" + chn.ToString();
                        old_value = slowConfig.get_property(slowConfig.settings[Key.ToString()]);
                        new_value = (old_value & 0xFD) + value << 1; //0xFD is 111111 01
                        slowConfig.set_property(slowConfig.settings[Key.ToString()], new_value);
                    }
                    refreshParamPanel_2B();
                }
            }
        }

        private void discri_Changed(object sender, EventArgs e)
        {
            int chnNum;
            string controlName = (sender as Control).Name;
            Regex chnNum_reg = new Regex(@"discri_checkbox(\d+)");

            var result = chnNum_reg.Match(controlName);
            chnNum = int.Parse(result.Groups[1].Value);
            //is checkbox whose name is inputdacx_enable;
            bool isMasked = (sender as CheckBox).Checked;
            uint value = isMasked ? 1U : 0U;

            if(chnNum>=18)
            {
                
                uint old_value = slowConfig.get_property(slowConfig.settings["DISCRIMINATOR_MASK1"]);
                uint new_value = (old_value & ~(1U << (chnNum - 18))) | (value << (chnNum - 18));
                slowConfig.set_property(slowConfig.settings["DISCRIMINATOR_MASK1"], new_value);

            }
            else
            {
                uint old_value = slowConfig.get_property(slowConfig.settings["DISCRIMINATOR_MASK2"]);
                uint new_value = (old_value & ~(1U << chnNum)) | (value << chnNum);
                slowConfig.set_property(slowConfig.settings["DISCRIMINATOR_MASK2"], new_value);
            }          


        }

        private void saveSetting_btn_Click(object sender, EventArgs e)
        {

            slowConfig.settingName = setting_name.Text;
            slowConfig.save_settings(settingChoosen);
            switch(settingChoosen)
            {
                case 1:
                    config_set1.Text = setting_name.Text;
                    break;
                case 2:
                    config_set2.Text = setting_name.Text;
                    break;
                case 3:
                    config_set3.Text = setting_name.Text;
                    break;
                case 4:
                    config_set4.Text = setting_name.Text;
                    break;
                default:
                    MessageBox.Show("Please choose which setting plot you want to use", "Error");
                    break;
            }
        }

        private void setting_Choosen(object sender, EventArgs e)
        {
            if (config_set1.Checked == true)
            {
                settingChoosen = 1;
            }
            else if (config_set2.Checked == true)
            {
                settingChoosen = 2;
            }
            else if (config_set3.Checked == true)
            {
                settingChoosen = 3;
            }
            else if (config_set4.Checked == true)
            {
                settingChoosen = 4;
            }
        }

        private void hgShapeValue_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(hgShapeValue.Text))
            {
                value = uint.Parse(hgShapeValue.Text);
                if (0 <= value && value <= 7)
                {
                    slowConfig.set_property(slowConfig.settings["HG_SS_TIME_CONSTANT"], value);
                    return;
                }
            }

            MessageBox.Show("value need be in range of 0-7", "Value invalid");

        }

        private void lgShapeValue_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(lgShapeValue.Text))
            {
                value = uint.Parse(lgShapeValue.Text);
                if (0 <= value && value <= 7)
                {
                    slowConfig.set_property(slowConfig.settings["LG_SS_TIME_CONSTANT"], value);
                    return;
                }
            }

            MessageBox.Show("value need be in range of 0-7", "Value invalid");

        }

        private void hgAmpComp_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(hgAmpComp.Text))
            {
                value = uint.Parse(hgAmpComp.Text);
                if (0 <= value && value <= 15)
                {
                    slowConfig.set_property(slowConfig.settings["CAP_HG_PA_COMPENSATION"], value);
                    return;
                }
            }

            MessageBox.Show("value need be in range of 0-15", "Value invalid");

        }

        private void lgAmpComp_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(lgAmpComp.Text))
            {
                value = uint.Parse(lgAmpComp.Text);
                if (0 <= value && value <= 15)
                {
                    slowConfig.set_property(slowConfig.settings["CAP_LG_PA_COMPENSATION"], value);
                    return;
                }
            }

            MessageBox.Show("value need be in range of 0-15", "Value invalid");

        }

        private void startrampDelay_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(startrampDelay.Text))
            {
                value = uint.Parse(startrampDelay.Text);
                if (0 <= value && value <= 63)
                {
                    slowConfig.set_property(slowConfig.settings["DELAY_START_RAMP_TDC"], value);
                    return;
                }
            }

            MessageBox.Show("value need be in range of 0-63", "Value invalid");

        }

        private void triggerDelay_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(triggerDelay.Text))
            {
                value = uint.Parse(triggerDelay.Text);
                if (version_num ==1)
                {
                    if(0 <= value && value <= 63)
                    {
                        slowConfig.set_property(slowConfig.settings["DELAY_TRIGGER"], value);
                    }
                    else
                    {
                        MessageBox.Show("value need be in range of 0-63", "Value invalid");
                    }
                }
                else if(version_num == 2)
                {
                    if(0<= value && value <= 255)
                    {
                        slowConfig.set_property(slowConfig.settings["DELAY_TRIGGER"], value);
                    }
                    else
                    {
                        MessageBox.Show("value need be in range of 0-63", "Value invalid");
                    }
                }
            }         
        }

        private void validholdDelay_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(validholdDelay.Text))
            {
                value = uint.Parse(validholdDelay.Text);
                if (0 <= value && value <= 63)
                {
                    slowConfig.set_property(slowConfig.settings["DELAY_VALIDHOLD"], value);
                    return;
                }
            }

            MessageBox.Show("value need be in range of 0-63", "Value invalid");

        }

        private void rstcolDelay_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(rstcolDelay.Text))
            {
                value = uint.Parse(rstcolDelay.Text);
                if (0 <= value && value <= 63)
                {
                    slowConfig.set_property(slowConfig.settings["DELAY_RSTCOL"], value);
                    return;
                }
            }

            MessageBox.Show("value need be in range of 0-63", "Value invalid");

        }


        private void adcResolution_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);
            // check input valid
            if (rx_int.IsMatch(adcResolution.Text))
            {
                value = uint.Parse(adcResolution.Text);
                if (0 <= value && value <= 4095)
                {
                    slowConfig.set_property(slowConfig.settings["ADC_GRAY"], value);
                    return;
                }
            }

            MessageBox.Show("12bit Gray Code, LSB -> MSB", "Value invalid");
        }

        private void chipID_TextChanged(object sender, EventArgs e)
        {
            uint value = 0;
            Regex rx_int = new Regex(rx_Integer);

            // check input valid
            if (rx_int.IsMatch(chipID.Text))
            {
                value = uint.Parse(chipID.Text);
                if (0 <= value && value <= 255)
                {
                    slowConfig.set_property(slowConfig.settings["CHIPID"], value);
                    return;
                }
            }

            MessageBox.Show("8bit chipID, and will show in data the way of Gray", "Value Error");
        }

        private void adcRampSlope_combo_SelectedIndexChanged(object sender, EventArgs e)
        {
            uint value = 0;
            switch (adcRampSlope_combo.SelectedIndex)
            {
                case 0:
                    value = 0;
                    break;
                case 1:
                    value = 2;
                    break;
                case 2:
                    value = 3;
                    break;
                default:
                    value = 1;  // error
                    break;
            }
            if (value != 1)
            {
                slowConfig.set_property(slowConfig.settings["ADC_RAMP_SLOPE"], value);
                return;
            }
            MessageBox.Show("Item selected is invalid", "Value Invalid");
        }

        private void tdcRampSlope_combo_SelectedIndexChanged(object sender, EventArgs e)
        {
            uint value = 0;
            switch (tdcRampSlope_combo.SelectedIndex)
            {
                case 0:
                    value = 0;
                    break;
                case 1:
                    value = 1;
                    break;
                default:
                    value = 2;  // error
                    break;
            }
            if (value != 2)
            {
                slowConfig.set_property(slowConfig.settings["TDC_RAMP_SLOPE_GC"], value);
                return;
            }
            MessageBox.Show("Item selected is invalid", "Value Invalid");
        }

        private void fastShaperFrom_combo_SelectedIndexChanged(object sender, EventArgs e)
        {
            uint value = 0;
            switch (fastShaperFrom_combo.SelectedIndex)
            {
                case 0:
                    value = 1;
                    break;
                case 1:
                    value = 0;
                    break;
                default:
                    value = 2;  // error
                    break;
            }
            if (value != 2)
            {
                slowConfig.set_property(slowConfig.settings["FS"], value);
                return;
            }
            MessageBox.Show("Item selected is invalid", "Value Invalid");
        }

        private void adjust4BitDAC_combo_SelectedIndexChanged(object sender, EventArgs e)
        {
            uint value = 0;
            switch (adjust4BitDAC_combo.SelectedIndex)
            {
                case 0:
                    value = 0;
                    break;
                case 1:
                    value = 1;
                    break;
                default:
                    value = 2;  // error
                    break;
            }
            if (value != 2)
            {
                slowConfig.set_property(slowConfig.settings["ADJUST_4BIT_DAC"], value);
                return;
            }
            MessageBox.Show("Item selected is invalid", "Value Invalid");
        }

        private void triggerExt_enable_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if(triggerExt_enable.Checked == true)
            {
                triggerExt_enable.Text = "\tEnable";
                value = 1;
            }
            else
            {
                triggerExt_enable.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["TRIG_EXT"], value);
        }

        private void flagTdcExt_enable_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (flagTdcExt_enable.Checked == true)
            {
                flagTdcExt_enable.Text = "\tEnable";
                value = 1;
            }
            else
            {
                flagTdcExt_enable.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["FLAG_TDC_EXT"], value);
        }

        private void startRampAdcExt_enable_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (startRampAdcExt_enable.Checked == true)
            {
                startRampAdcExt_enable.Text = "\tEnable";
                value = 1;
            }
            else
            {
                startRampAdcExt_enable.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["START_RAMP_ADC_EXT"], value);
        }

        private void startRampTdcExt_enable_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (startRampTdcExt_enable.Checked == true)
            {
                startRampTdcExt_enable.Text = "\tEnable";
                value = 1;
            }
            else
            {
                startRampTdcExt_enable.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["START_RAMP_TDC_EXT"], value);
        }

        private void probe_enable_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (probe_enable.Checked == true)
            {
                probe_enable.Text = "\tEnable";
                value = 1;
            }
            else
            {
                probe_enable.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["PROBE_OTA"], value);
        }

        private void analogOutput_enable_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (analogOutput_enable.Checked == true)
            {
                analogOutput_enable.Text = "\tEnable";
                value = 1;
            }
            else
            {
                analogOutput_enable.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["ENABLE_ANALOGUE_OUTPUT"], value);
        }

        private void or36_enable_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (or36_enable.Checked == true)
            {
                or36_enable.Text = "\tEnable";
                value = 0;
            }
            else
            {
                or36_enable.Text = "\tDisable";
                value = 1;
            }
            slowConfig.set_property(slowConfig.settings["EN_OR36"], value);
        }

        private void backSCA_enable_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (backSCA_enable.Checked == true)
            {
                backSCA_enable.Text = "\tEnable";
                value = 1;
            }
            else
            {
                backSCA_enable.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["BACKUP_SCA"], value);
        }

        private void recallSetting_btn_Click(object sender, EventArgs e)
        {
            slowConfig.recall_settings(settingChoosen);

            switch (settingChoosen)
            {
                case 1:
                    config_set1.Text = slowConfig.settingName;
                    break;
                case 2:
                    config_set2.Text = slowConfig.settingName;
                    break;
                case 3:
                    config_set3.Text = slowConfig.settingName;
                    break;
                case 4:
                    config_set4.Text = slowConfig.settingName;
                    break;
                default:
                    MessageBox.Show("Please choose which setting plot you want to use", "Error");
                    break;
            }
            if (version_num ==1)
            {
                refreshParamPanel_2B();
            }
            else
            {
                refreshParamPanel_2E();
            }
        }

        private void analog_output_select_ValueChanged(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];
            commandByte[1] = 0x0a;
            commandByte[0] = byte.Parse(analog_output_select.Value.ToString());
            var isUSBConnected = check_USB();
            if(isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }
            
            textBox1.AppendText("Channel " + analog_output_select.Value.ToString() + " has been selected for observing\n");
        }

        private void flag_tdc_ext_pin_CheckedChanged(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];
            commandByte[1] = 0x09;
            commandByte[0] = flag_tdc_ext_pin.Checked ? (byte)0x01 : (byte)0x00;

            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }

            textBox1.AppendText("Flag tdc pin has been set:" + (flag_tdc_ext_pin.Checked ? "high" :"low"));

        }

        private void Ext_trigger_fpga_enable_CheckedChanged(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];
            commandByte[1] = 0x0c;
            commandByte[0] = Ext_trigger_fpga_enable.Checked ? (byte)0x04 : (byte)0x00;

            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }

            textBox1.AppendText("Ext trigger has been changed\n");
        }

        private void autoGain_Check_CheckedChanged(object sender, EventArgs e)
        {
            uint value = autoGain_Check.Checked ? 1U : 0U;
            autoGain_Check.Text = autoGain_Check.Checked ? "High" : "Low";
            slowConfig.set_property(slowConfig.settings["AUTO_GAIN"], value);

        }

        private void gainSelect_Check_CheckedChanged(object sender, EventArgs e)
        {
            uint value = gainSelect_Check.Checked ? 1U : 0U;
            gainSelect_Check.Text = gainSelect_Check.Checked ? "High" : "Low";
            slowConfig.set_property(slowConfig.settings["GAIN_SELECT"], value);
        }

        private void adcExtInput_Check_CheckedChanged(object sender, EventArgs e)
        {
            uint value = adcExtInput_Check.Checked ? 1U : 0U;
            adcExtInput_Check.Text = adcExtInput_Check.Checked ? "Enable" : "Disable";
            slowConfig.set_property(slowConfig.settings["ADC_EXT_INPUT"], value);
        }

        private void switchTDCon_Check_CheckedChanged(object sender, EventArgs e)
        {
            uint value = switchTDCon_Check.Checked ? 1U : 0U;
            switchTDCon_Check.Text = switchTDCon_Check.Checked ? "High" : "Low";
            slowConfig.set_property(slowConfig.settings["SWITCH_TDC_ON"], value);
        }

        private void bandGap_Check_CheckedChanged(object sender, EventArgs e)
        {
            uint value = bandGap_Check.Checked ? 1U : 0U;
            bandGap_Check.Text = bandGap_Check.Checked ? "Enable" : "Disable";
            slowConfig.set_property(slowConfig.settings["EN_BANDGAP"], value);
        }

        private void dacEnable_Check_CheckedChanged(object sender, EventArgs e)
        {
            uint value = dacEnable_Check.Checked ? 1U : 0U;
            dacEnable_Check.Text = dacEnable_Check.Checked ? "Enable" : "Disable";
            slowConfig.set_property(slowConfig.settings["EN_DAC"], value);
        }
        

        private void HV_value_ValueChanged(object sender, EventArgs e)
        {

        }

        private void afg3252_btn_Click(object sender, EventArgs e)
        {
            /*
             * Use CyUSB driver, which is not valid
            string cmd = afg3252_cmd.Text;
            byte[] cmdCharShort = Encoding.Default.GetBytes(cmd);
            byte[] cmd_byte = new byte[100];
            cmdCharShort.CopyTo(cmd_byte,0);
            cmd_byte[cmd.Length] = 0x00;
            if(AFGcmdSend(cmd_byte, cmd.Length + 1) == false)
            {
                MessageBox.Show("AFG command sending failed", "Error");

            }
            */
            try
            {
                SignalSource.Write(afg3252_cmd.Text);
            }
            catch (Exception exp)
            {
                MessageBox.Show(exp.Message);
            }

        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            DateTime now = DateTime.Now;
            TimeSpan duration = now - startTime;
            time_textbox.Text = string.Format("{0:hh}:{0:mm}:{0:ss}.{0:ff}", duration);

            }


        private void voltageSweep_btn_Click(object sender, EventArgs e)
        {

            voltageSweepTks.Dispose();       //clean up old token source
            voltageSweepTks = new CancellationTokenSource(); // generate a new token
            if(check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected", "Error");
                return;
            }
            if(usbStatus == true)
            {
                try
                {
                    Task voltageSweepTask = Task.Factory.StartNew(() => this.voltageSweep_threadFunc(voltageSweepTks.Token), voltageSweepTks.Token);
                    startTime = DateTime.Now;
                    timer1.Start();
                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
            }


            Acq_status_label.Text = "Voltage Sweep";
            Acq_status_label.ForeColor = Color.Green;

        }

        private void volSweepStop_btn_Click(object sender, EventArgs e)
        {
            voltageSweepTks.Cancel();
            textBox1.AppendText("Sweep stop\n");
            Acq_status_label.Text = "IDLE";
            Acq_status_label.ForeColor = Color.Black;
        }

        private void scSweep_btn_Click(object sender, EventArgs e)
        {
            scSweepTks.Dispose();       //clean up old token source
            scSweepTks = new CancellationTokenSource(); // generate a new token
            if (check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected");
                return;
            }

            string selectPara = scSweepPara_select.SelectedItem.ToString();
            switch(selectPara)
            {
                case "preamp":
                    try
                    {
                        Task scSweepTask = Task.Factory.StartNew(() => this.preampSweep_threadFunc(scSweepTks.Token), scSweepTks.Token);

                    }
                    catch (AggregateException excption)
                    {

                        foreach (var v in excption.InnerExceptions)
                        {

                            exceptionReport.AppendLine(excption.Message + " " + v.Message);
                        }

                    }
                    break;

                default:
                    try
                    {
                        Task scSweepTask = Task.Factory.StartNew(() => this.scSweep_threadFunc(scSweepTks.Token, selectPara), scSweepTks.Token);

                    }
                    catch (AggregateException excption)
                    {

                        foreach (var v in excption.InnerExceptions)
                        {

                            exceptionReport.AppendLine(excption.Message + " " + v.Message);
                        }

                    }
                    break;

            }
                
           
            Acq_status_label.Text = "SC sweep";
            Acq_status_label.ForeColor = Color.Green;
        }

        private void scSweepStop_btn_Click(object sender, EventArgs e)
        {
            scSweepTks.Cancel();
            textBox1.AppendText("Sweep stop\n");
            Acq_status_label.Text = "IDLE";
            Acq_status_label.ForeColor = Color.Black;
        }

        private void delayMatrix_task_Click(object sender, EventArgs e)
        {
            specialTaskTks.Dispose();       //clean up old token source
            specialTaskTks = new CancellationTokenSource(); // generate a new token
            if (check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected", "Error");
                return;
            }

            Form2 paraWindows = new Form2();
            paraWindows.label1.Text = "delay of asic";
            paraWindows.label2.Text = "delay of AFG3252";
            paraWindows.ShowDialog(this);


            if (paraWindows.confirm == false)
            {
                return;
            }
            if (usbStatus == true)


                try
                {
                    Task voltageSweepTask = Task.Factory.StartNew(() => this.delayMatrix_threadFunc(specialTaskTks.Token,paraWindows), specialTaskTks.Token);

                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
            Acq_status_label.Text = "Delay Matrix Sweep";
            Acq_status_label.ForeColor = Color.Green;
        }

        private void preampWaveform_task_Click(object sender, EventArgs e)
        {
            specialTaskTks.Dispose();       //clean up old token source
            specialTaskTks = new CancellationTokenSource(); // generate a new token
            if (check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected", "Error");
                return;
            }
            if (usbStatus == true)
            {
                Form2 paraWindows = new Form2();
                paraWindows.label1.Text = "preamp gain";
                paraWindows.label2.Text = "delay of trigger internal ";
                paraWindows.ShowDialog(this);

                try
                {
                    Task voltageSweepTask = Task.Factory.StartNew(() => this.preampDelay_sweep_threadFunc(specialTaskTks.Token, paraWindows), specialTaskTks.Token);

                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
            }
            Acq_status_label.Text = "Preamp & Delay Sweep";
            Acq_status_label.ForeColor = Color.Green;
        }

        private void volDelay_sweep_Click(object sender, EventArgs e)
        {
            specialTaskTks.Dispose();       //clean up old token source
            specialTaskTks = new CancellationTokenSource(); // generate a new token
            if (check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected", "Error");
                return;
            }

            Form2 paraWindows = new Form2();
            paraWindows.label1.Text = "input voltage";
            paraWindows.label2.Text = "delay of asic";
            paraWindows.ShowDialog(this);

            if (usbStatus == true)


                try
                {
                    Task voltageSweepTask = Task.Factory.StartNew(() => this.volDelay_sweep_threadFunc(specialTaskTks.Token, paraWindows), specialTaskTks.Token);

                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
            Acq_status_label.Text = "Sweep";
            Acq_status_label.ForeColor = Color.Green;
        }

        private void folderBrowserDialog1_HelpRequest(object sender, EventArgs e)
        {

        }

        private void LED_calib_btn_Click(object sender, EventArgs e)
        {
            voltageSweepTks.Dispose();       //clean up old token source
            voltageSweepTks = new CancellationTokenSource(); // generate a new token
            if (check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected", "Error");
                return;
            }

            Form2 paraWindows = new Form2();
            paraWindows.label1.Text = "input voltage";
            paraWindows.label2.Text = "don't touch this line";
            paraWindows.ShowDialog(this);

            if (usbStatus == true)
            {
                try
                {
                    Task voltageSweepTask = Task.Factory.StartNew(() => this.ledCalib_threadFunc(voltageSweepTks.Token, paraWindows), voltageSweepTks.Token);
                    startTime = DateTime.Now;
                    timer1.Start();
                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
            }


            Acq_status_label.Text = "Voltage Sweep";
            Acq_status_label.ForeColor = Color.Green;

        }

        private void pwr_on_a_checkbox_CheckedChanged(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];

            commandByte[1] = 0x0d;
            if(pwr_on_a_checkbox.Checked)
            {
                commandByte[0] = (byte)(0x08 | pwr_vector);
            }
            else
            {
                commandByte[0] = (byte)(0x07 & pwr_vector);
            }
            pwr_vector = commandByte[0];
            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }


            textBox1.AppendText("Power on A has been changed\n");
        }

        private void pwr_on_D_checkbox_CheckedChanged(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];

            commandByte[1] = 0x0d;
            if (pwr_on_D_checkbox.Checked)
            {
                commandByte[0] = (byte)(0x04 | pwr_vector);
            }
            else
            {
                commandByte[0] = (byte)(0x0B & pwr_vector);
            }
            pwr_vector = commandByte[0];
            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }


            textBox1.AppendText("Power on D has been changed\n");
        }

        private void pwr_on_ADC_checkbox_CheckedChanged(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];

            commandByte[1] = 0x0d;
            if (pwr_on_ADC_checkbox.Checked)
            {
                commandByte[0] = (byte)(0x02 | pwr_vector);
            }
            else
            {
                commandByte[0] = (byte)(0x0D & pwr_vector);
            }
            pwr_vector = commandByte[0];
            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }


            textBox1.AppendText("Power on ADC has been changed\n");
        }

        private void pwr_on_DAC_checkbox_CheckedChanged(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];

            commandByte[1] = 0x0d;
            if (pwr_on_DAC_checkbox.Checked)
            {
                commandByte[0] = (byte)(0x01 | pwr_vector);
            }
            else
            {
                commandByte[0] = (byte)(0x0E & pwr_vector);
            }
            pwr_vector = commandByte[0];
            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }


            textBox1.AppendText("Power on DAC has been changed\n");
        }

        private void eventNumPackage_ValueChanged(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];

            commandByte[1] = 0x0e;
            commandByte[0] = byte.Parse(eventNumPackage.Value.ToString());
            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }

            textBox1.AppendText("The maxium number of trigger in one package has been set to " + eventNumPackage.Value.ToString() + ".\n");
        }

        private void Main_group_Enter(object sender, EventArgs e)
        {

        }

        private void textBox12_TextChanged(object sender, EventArgs e)
        {

        }

        private void trig_dac_value_TextChanged_1(object sender, EventArgs e)
        {

        }

        private void normal_usbcon_button_Click_1(object sender, EventArgs e)
        {

        }

        private void normal_config_button_Click_1(object sender, EventArgs e)
        {

        }

        private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
        {
            if ( comboBox1.Text == "SPIROC2B")
            {
                version_num = 1;
            }
            if (comboBox1 .Text == "SPIROC2E")
            {
                version_num = 2;
            }
            if (version_num == 1)
            {
                slowConfig = slowConfig_2B_store[0];
                slowConfig.save_settings(0);
            }
            if (version_num == 2)
            {
                slowConfig = slowConfig_2E_1;
                slowConfig.save_settings(0);
                HLGain_Select.Enabled = false;
                
            }
        }

        private void splitContainer1_Panel2_Paint(object sender, PaintEventArgs e)
        {

        }
        private void Sel_Temp_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (Sel_Temp.Checked == true)
            {
                Sel_Temp.Text = "\tEnable";
                value = 1;
            }
            else
            {
                Sel_Temp.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["Sel_Temp_sensor_to_ADC_GC"], value);
        }
        private void EN_input_dac_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (EN_input_dac.Checked == true)
            {
                EN_input_dac.Text = "\tEnable";
                value = 1;
            }
            else
            {
                EN_input_dac.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["EN_input_dac"], value);
        }
        private void GC8bitDAC_SelectedIndexChanged(object sender, EventArgs e)
        {
            uint value = 0;
            switch (GC8bitDAC.SelectedIndex)
            {
                case 0:
                    value = 1;
                    break;
                case 1:
                    value = 0;
                    break;
                default:
                    value = 2;  // error
                    break;
            }
            if (value != 2)
            {
                slowConfig.set_property(slowConfig.settings["GC_8_bit_DAC_reference"], value);
                return;
            }
            MessageBox.Show("Item selected is invalid", "Value Invalid");
        }
        private void LG_PAbias_SelectedIndexChanged(object sender, EventArgs e)
        {
            uint value = 0;
            switch (LG_PAbias.SelectedIndex)
            {
                case 0:
                    value = 1;
                    break;
                case 1:
                    value = 0;
                    break;
                default:
                    value = 2;  // error
                    break;
            }
            if (value != 2)
            {
                slowConfig.set_property(slowConfig.settings["LG_PA_bias"], value);
                return;
            }
            MessageBox.Show("Item selected is invalid", "Value Invalid");
        }
        private void ENHighGain_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (ENHighGain.Checked == true)
            {
                ENHighGain.Text = "\tEnable";
                value = 1;
            }
            else
            {
                ENHighGain.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["EN_High_Gain_PA"], value);
        }
        private void ENLowGain_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (ENLowGain.Checked == true)
            {
                ENLowGain.Text = "\tEnable";
                value = 1;
            }
            else
            {
                ENLowGain.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["EN_Low_Gain_PA"], value);
        }
        private void FastShaperLG_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (FastShaperLG.Checked == true)
            {
                FastShaperLG.Text = "\tEnable";
                value = 1;
            }
            else
            {
                FastShaperLG.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["Fast_Shaper_on_LG"], value);
        }
        private void EN_LowGainSS_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (EN_LowGainSS.Checked == true)
            {
                EN_LowGainSS.Text = "\tEnable";
                value = 1;
            }
            else
            {
                EN_LowGainSS.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["EN_Low_Gain_Slow_Shaper"], value);
        }
        private void ENHGSS_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (ENHGSS.Checked == true)
            {
                ENHGSS.Text = "\tEnable";
                value = 1;
            }
            else
            {
                ENHGSS.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["ENABLE_HG_SS"], value);
        }
        private void EN_FS_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (EN_FS.Checked == true)
            {
                EN_FS.Text = "\tEnable";
                value = 1;
            }
            else
            {
                EN_FS.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["EN_FS"], value);
        }
        private void GC_TempSensor_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (GC_TempSensor.Checked == true)
            {
                GC_TempSensor.Text = "\tEnable";
                value = 1;
            }
            else
            {
                GC_TempSensor.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["GC_Temp_sensor_high_current"], value);
        }
        private void ENTemp_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (ENTemp.Checked == true)
            {
                ENTemp.Text = "\tEnable";
                value = 1;
            }
            else
            {
                ENTemp.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["EN_Temp"], value);
        }
        private void ENDac1_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (ENDac1.Checked == true)
            {
                ENDac1.Text = "\tEnable";
                value = 1;
            }
            else
            {
                ENDac1.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["EN_DAC1"], value);
        }
        private void ENDac2_CheckedChanged(object sender, EventArgs e)
        {

        }
        private void TDCRampEN_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (TDCRampEN.Checked == true)
            {
                TDCRampEN.Text = "\tEnable";
                value = 1;
            }
            else
            {
                TDCRampEN.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["TDC_RAMP_EN"], value);
        }
        private void DIsctriDelayVref_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (DIsctriDelayVref.Checked == true)
            {
                DIsctriDelayVref.Text = "\tEnable";
                value = 1;
            }
            else
            {
                DIsctriDelayVref.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["Discri_Delay_Vref_I_source_EN"], value);
        }
        private void ENLvdsNotrig_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (ENLvdsNotrig.Checked == true)
            {
                ENLvdsNotrig.Text = "\tEnable";
                value = 1;
            }
            else
            {
                ENLvdsNotrig.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["EN_LVDS_receiver_NoTrig"], value);
        }
        private void ENLvdsValEvt_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (ENLvdsValEvt.Checked == true)
            {
                ENLvdsValEvt.Text = "\tEnable";
                value = 1;
            }
            else
            {
                ENLvdsValEvt.Text = "\tDisable";
                value = 0;
            }
            slowConfig.set_property(slowConfig.settings["EN_LVDS_receiver_ValEvt"], value);
        }
        private void ENLvdsTrigExt_CheckedChanged(object sender, EventArgs e)
        {
            uint value = 0;
            if (ENLvdsTrigExt.Checked == true)
            {
                ENLvdsTrigExt.Text = "\tEnable";
                value = 1;
            }
            else
            {
                ENLvdsTrigExt.Text = "\tDisable";
                value = 0; 
            }
            slowConfig.set_property(slowConfig.settings["EN_LVDS_receiver_TrigExt"], value);
        }

        private void debug_cmd_send_bt_Click(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];

            Int16 cmd_int = Convert.ToInt16(debug_cmd_text.Text, 16);
            commandByte[1] = (byte)(cmd_int >> 8);
            commandByte[0] = (byte)cmd_int;

            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }

            textBox1.AppendText("Test Cmd:" + debug_cmd_text.Text +"\nhas been sent.\n");

        }

        private void debug_rxdata_Click(object sender, EventArgs e)
        {
            if (debug_rxdata.Tag.ToString() == "0")
            {

                dataAcqTks.Dispose();       //clean up old token source
                dataAcqTks = new CancellationTokenSource(); // generate a new token         

                // create file writer
                fileName = string.Format("{0:yyyyMMdd_HHHHmmss}", DateTime.Now) + ".dat";
                if (!Directory.Exists(fileDic))
                {
                    Directory.CreateDirectory(fileDic);
                }

                BinaryWriter bw = new BinaryWriter(File.Open(fileDic + "\\\\" + fileName, FileMode.Append, FileAccess.Write, FileShare.Read));
                resultRecord = new FileStream(fileDic + '\\' + recordPath, FileMode.Append);

                // Start data acquision thread
                try
                {
                    Task dataAcqTsk = Task.Factory.StartNew(() => this.dataAcq_threadFunc(dataAcqTks.Token, bw), dataAcqTks.Token);
                    startTime = DateTime.Now;
                    timer1.Start();
                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
                debug_rxdata.Text = "Stop";
                debug_rxdata.BackColor = Color.PeachPuff;
                debug_rxdata.ForeColor = Color.White;
                debug_rxdata.Tag = 1;
            }
            else
            {
                dataAcqTks.Cancel();
                debug_rxdata.Text = "Receive Data";
                debug_rxdata.BackColor = Color.White;
                debug_rxdata.ForeColor = Color.Black;
                debug_rxdata.Tag = 0;
            }
            
        }

        private void calib_status_Click(object sender, EventArgs e)
        {
            if(calib_status.Tag.ToString() == "0")
            {
                if (calib_turnOn())
                {
                    calib_status.Tag = 1;
                    calib_status.Text = "READY";
                    calib_status.BackColor = Color.MediumSeaGreen;
                    //calib_trig.Enabled = true;
                }
                else
                {
                    MessageBox.Show("Can't send command");
                }
            }
            else if(calib_status.Tag.ToString() == "1")
            {
                if (calib_turnOff())
                {
                    calib_status.Tag = 0;
                    calib_status.Text = "OFF";
                    calib_status.BackColor = Color.DarkRed;
                    //calib_trig.Enabled = false;
                }
                else
                {
                    MessageBox.Show("Can't send command");
                }
            }
        }

        private void calib_trig_Click(object sender, EventArgs e)
        {
            calib_S_pulse();
        }

        private void auto_calib_btn_Click(object sender, EventArgs e)
        {
            bool isAutoNow = (auto_calib_status.Tag.ToString() == "1");
            byte[] cmdbytes = new byte[2];
            if (isAutoNow)
            {
                cmdbytes[1] = 0x12;
                cmdbytes[0] = 0x00;
                if (CommandSend(cmdbytes, 2))
                {
                    auto_calib_status.Tag = 0;
                    auto_calib_status.BackColor = Color.LightGray;
                    auto_calib_status.Text = "MANUAL";
                }
                else
                {
                    MessageBox.Show("Can't send command");
                }             
    
            }
            else
            {
                cmdbytes[1] = 0x12;
                cmdbytes[0] = 0x01;
                if(CommandSend(cmdbytes, 2))
                {
                    auto_calib_status.Tag = 1;
                    auto_calib_status.BackColor = Color.Gold;
                    auto_calib_status.Text = "AUTO";
                }
                else
                {
                    MessageBox.Show("Can't send command");
                }


            }
        }

        private void Calib_groupSel_ValueChanged(object sender, EventArgs e)
        {
            byte[] cmdbytes = new byte[2];

            cmdbytes[1] = 0x0b;
            cmdbytes[0] = byte.Parse((Calib_groupSel.Value-1).ToString());
            CommandSend(cmdbytes, 2);
        }

        private void calib_dac_text_TextChanged(object sender, EventArgs e)
        {
            byte[] cmdbytes = new byte[2];
            cmdbytes[1] = 0x07;
            byte value_h = 0x00;
            byte value_l = 0x00;

            uint value = 0;
            if(calib_dac_text.Text == null)
            {
                calib_dac_text.Text = "0";
            }
            value = uint.Parse(calib_dac_text.Text);
            value_h = (byte)(value >> 8);
            value_l = (byte)value;

            cmdbytes[0] = value_h;
            CommandSend(cmdbytes, 2);
            cmdbytes[0] = value_l;
            CommandSend(cmdbytes, 2);

            byte chn1_mask = 0x80;
            value_h = (byte)(chn1_mask|value_h);

            cmdbytes[0] = value_h;
            CommandSend(cmdbytes, 2);
            cmdbytes[0] = value_l;
            CommandSend(cmdbytes, 2);

        }

        private void inter_calib_btn_Click(object sender, EventArgs e)
        {
            specialTaskTks.Dispose();       //clean up old token source
            specialTaskTks = new CancellationTokenSource(); // generate a new token
            if (check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected", "Error");
                return;
            }

            if (usbStatus == true)


                try
                {
                    Task electonicCalib = Task.Factory.StartNew(() => this.electronicSweep_threadFunc(specialTaskTks.Token), specialTaskTks.Token);

                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
            Acq_status_label.Text = "Calib";
            Acq_status_label.ForeColor = Color.Green;
        }

        private void task_stop_btn_Click(object sender, EventArgs e)
        {
            specialTaskTks.Cancel();
            textBox1.AppendText("Special Task stop\n");
            Acq_status_label.Text = "IDLE";
            Acq_status_label.ForeColor = Color.Black;
        }

        private void chip_num_input_ValueChanged(object sender, EventArgs e)
        {
            int chip_num = (int)chip_num_input.Value;
            CommandSend(0x1300 + chip_num, 2);
        }

        private void HVswitch_btn_Click(object sender, EventArgs e)
        {
            bool status;
            string cmd = "";
            status = (HVswitch_btn.Tag.ToString() == "1");

            if (status == true)
            {
                try
                {
                    hv_setTks.Cancel();
                    hv_setTks.Dispose();       //clean up old token source
                    hv_setTks = new CancellationTokenSource(); // generate a new token
                    HV_value.Value = 50;
                    Task hv_setting = Task.Factory.StartNew(() => this.HV_set_smooth_threadFunc(hv_setTks.Token, true, false), hv_setTks.Token);

                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
                HVswitch_btn.Text = "Open";
                HV_status_label.Text = "OFF";
                HV_status_label.ForeColor = Color.Red;
                HVswitch_btn.Tag = 0;
            }
            else if(status == false)
            {
                hv_switch(true);
                HVswitch_btn.Text = "Close";
                HV_status_label.Text = "ON";
                HV_status_label.ForeColor = Color.Green;
                HVswitch_btn.Tag = 1;
            }

        }

        private void HV_CompSwitch_btn_Click(object sender, EventArgs e)
        {
            bool status;
            string cmd = "";
            status = (HV_CompSwitch_btn.Tag.ToString() == "1");
            if (status == true)
            {
                cmd = "HCM0";
                HVswitch_btn.Text = "Comp. OFF";
                HVswitch_btn.Tag = 0;
            }
            else if (status == false)
            {
                cmd = "HCM1";
                HVswitch_btn.Text = "Comp. ON";
                HVswitch_btn.Tag = 1;
            }
            byte[] cmd_hex = new byte[100];
            int cmd_length = cmd.Length;
            cmd_hex = System.Text.Encoding.ASCII.GetBytes(cmd);
            cmd_length = 4;
            CommandSend(0x0503, 2); //选通HV control config sending channel
            uart_send(cmd_hex, cmd_length);
            CommandSend(0x0502, 2); //停止选通HV control config sending channel
        }

        private void hv_smooth_set_btn_Click(object sender, EventArgs e)
        {
            decimal target_voltage;
            target_voltage = HV_value.Value;
            hv_setTks.Cancel();
            hv_setTks.Dispose();       //clean up old token source
            hv_setTks = new CancellationTokenSource(); // generate a new token
            if (check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected", "Error");
                return;
            }

            if (usbStatus == true)


                try
                {
                    Task hv_setting = Task.Factory.StartNew(() => this.HV_set_smooth_threadFunc(hv_setTks.Token, false,false), hv_setTks.Token);

                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }

        }

        private void s_curve_btn_Click(object sender, EventArgs e)
        {
            specialTaskTks.Dispose();       //clean up old token source
            specialTaskTks = new CancellationTokenSource(); // generate a new token
            if (check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected", "Error");
                return;
            }

            Form2 paraWindows = new Form2();
            paraWindows.label1.Text = "dac sweep";
            paraWindows.label2.Text = "null";
            paraWindows.ShowDialog(this);


            if (paraWindows.confirm == false)
            {
                return;
            }
            if (usbStatus == true)
            {

                // create file writer
                fileName = string.Format("{0:yyyyMMdd_HHHHmmss}", DateTime.Now) + ".dat";
                if (!Directory.Exists(fileDic))
                {
                    Directory.CreateDirectory(fileDic);
                }

                BinaryWriter bw = new BinaryWriter(File.Open(fileDic + "\\\\" + fileName, FileMode.Append, FileAccess.Write, FileShare.Read));
                resultRecord = new FileStream(fileDic + '\\' + recordPath, FileMode.Append);
                try
                {
                    Task voltageSweepTask = Task.Factory.StartNew(() => this.s_curve_sweep_threadFunc(specialTaskTks.Token, paraWindows, bw), specialTaskTks.Token);

                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
                Acq_status_label.Text = "S curve acq";
                Acq_status_label.ForeColor = Color.Green;
            }
        }

        private void ext_calib_en_CheckedChanged(object sender, EventArgs e)
        {
            byte[] commandByte = new byte[2];
            commandByte[1] = 0x14;
            commandByte[0] = ext_calib_en.Checked ? (byte)0x01 : (byte)0x00;

            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                CommandSend(commandByte, 2);
            }
            else
            {
                MessageBox.Show("Please connect USB first", "Error");
                return;
            }

            textBox1.AppendText("Ext trigger of calib function has been changed\n");
        }

        private void slow_clock_combo_SelectedIndexChanged(object sender, EventArgs e)
        {          
            var isUSBConnected = check_USB();
            if(isUSBConnected)
            {
                switch (slow_clock_combo.SelectedIndex)
                {
                    case 0:
                        CommandSend(0x1500, 2);
                        textBox1.AppendText("Frequency of Slow Clock is 5MHz now\n");
                        break;
                    case 1:
                        CommandSend(0x1501, 2);
                        textBox1.AppendText("Frequency of Slow Clock is 1MHz now\n");
                        break;
                    case 2:
                        CommandSend(0x1502, 2);
                        textBox1.AppendText("Frequency of Slow Clock is 250KHz now\n");
                        break;
                    default:                    
                        break;
                }

            }
            else
            {
                MessageBox.Show("USB is not connected, please Check");
            }

        }

        private void sync_combo_SelectedIndexChanged(object sender, EventArgs e)
        {
            var isUSBConnected = check_USB();
            if (isUSBConnected)
            {
                switch (sync_combo.SelectedIndex)
                {
                    case 0:
                        CommandSend(0x1600, 2);
                        textBox1.AppendText("Sync signal output every 1000 Slow clock period\n");
                        break;
                    case 1:
                        CommandSend(0x1601, 2);
                        textBox1.AppendText("Sync signal output every 100 Slow clock period\n");
                        break;
                    case 2:
                        CommandSend(0x1602, 2);
                        textBox1.AppendText("Sync signal output every 10 Slow clock period\n");
                        break;
                    case 3:
                        CommandSend(0x1603, 2);
                        textBox1.AppendText("Sync signal output every 2 Slow clock period\n");
                        break;
                    default:
                        break;
                }

            }
            else
            {
                MessageBox.Show("USB is not connected, please Check");
            }


        }

        private void tdc_sweep_btn_Click(object sender, EventArgs e)
        {
            specialTaskTks.Dispose();       //clean up old token source
            specialTaskTks = new CancellationTokenSource(); // generate a new token
            if (check_USB() == false)
            {
                MessageBox.Show("USB or Instrument is not connected", "Error");
                return;
            }

            Form2 paraWindows = new Form2();
            paraWindows.label1.Text = "delay of AFG3252";
            paraWindows.ShowDialog(this);


            if (paraWindows.confirm == false)
            {
                return;
            }
            if (usbStatus == true)


                try
                {
                    Task voltageSweepTask = Task.Factory.StartNew(() => this.ext_trig_sweep_threadFunc(specialTaskTks.Token, paraWindows), specialTaskTks.Token);

                }
                catch (AggregateException excption)
                {

                    foreach (var v in excption.InnerExceptions)
                    {

                        exceptionReport.AppendLine(excption.Message + " " + v.Message);
                    }

                }
            Acq_status_label.Text = "TDC Testing";
            Acq_status_label.ForeColor = Color.Green;
        }

        private void File_path_showbox_TextChanged(object sender, EventArgs e)
        {

        }

        private void probe_set_btn_Click(object sender, EventArgs e)
        {
            var dac_p = dac_probe_select.Text;
            var ana_p = analog_probe_select.Text;
            var dig1_p = digital_probe1_select.Text;
            var dig2_p = digital_probe2_select.Text;

            Probe_config.init();
            uint dac_p_chn = (uint)dac_probe_chn.Value;
            uint ana_p_chn = (uint)analog_probe_chn.Value;
            uint dig1_p_chn = (uint)digital_probe1_chn.Value;
            uint dig2_p_chn = (uint)digital_probe2_chn.Value;

            uint gain = (uint)(HGLG_select_checkbox.Checked ? 1 : 0);

            uint depth_dig1 = (uint)dig1_depth.Value;
            uint depth_dig2 = (uint)dig2_depth.Value;
            Probe_config.set_property(dac_p, dac_p_chn, 0, 0);
            Probe_config.set_property(ana_p, ana_p_chn, 0, gain);
            Probe_config.set_property(dig1_p, dig1_p_chn, depth_dig1, 0);
            Probe_config.set_property(dig2_p, dig2_p_chn, depth_dig2, 0);

            int byte_count = 0;

            byte[] cmdBytes = new byte[2];
            byte[] bit_block = new byte[125];  //SPIROC2E has 992 Probe config bit, 992 / 8 = 124 , need 124 bytes

            byte_count = Probe_config.bit_transform(bit_block);

            // set probe/sc setting as probe
            CommandSend(0x0600, 2);

            // choose data transfer to sc buffer
            cmdBytes[1] = 0x05;
            cmdBytes[0] = 0x01;
            CommandSend(cmdBytes, 2);
            Thread.Sleep(100);
            // send config data
            cmdBytes[1] = 0x03;
            for (int i = 0; i < byte_count; i++)
            {
                cmdBytes[0] = bit_block[i];
                CommandSend(cmdBytes, 2);
                //Thread.Sleep(100);
            }

            // close channel of data to sc buffer
            cmdBytes[1] = 0x05;
            cmdBytes[0] = 0x00;

            CommandSend(cmdBytes, 2);

            // start slow config from fpga to asic
            cmdBytes[1] = 0x08;
            cmdBytes[0] = 0x00;
            CommandSend(cmdBytes, 2);

        }

        private void HLGain_Select_SelectedIndexChanged(object sender, EventArgs e)
        {
            refreshParamPanel_2E();
        }
    }
}
